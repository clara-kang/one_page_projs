
<!DOCTYPE html>
<html>
<body>
<style type="text/css">
body { margin:0; }
</style>

<script src='./models.js'></script>
<script src='./myshaders.js'></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
<script type="module">

import * as THREE from 'https://unpkg.com/three@0.119.0/build/three.module.js';
import {OBJLoader} from 'https://unpkg.com/three@0.119.0/examples/jsm/loaders/OBJLoader.js'
import {OrbitControls} from 'https://unpkg.com/three@0.119.0/examples/jsm/controls/OrbitControls.js'

let renderer;
let camera;
let gl;
let mouseX;
let mouseY;
let planeLocationOrientationChanged = false;
let planeOrientationChanged = false;
let planeScaleChanged = false;
let clickPos;
let clickNormal;
let intermediateRenderTarget;

let displayScene;

let planeMesh;

let meshDisplayMaterial;
let decalMaterial;
let planeMaterial;

let planeRotationTranslationMatrix = new THREE.Matrix4();
let planeScaleMatrix = new THREE.Matrix4();

let decalParameters = {
  orientation: Math.PI,
  size: 1.0
}

let lightParameters = {
  azimuth: Math.PI / 4.0,
  elevation: 0,
  ambient: 0.2
}

const uDirection = new THREE.Vector4(1.0, 0.0, 0.0, 0.0);

let main = () => {
  const normalScene = new THREE.Scene();
  displayScene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
  camera.position.z = 5;

  renderer = new THREE.WebGLRenderer();
  gl = renderer.getContext();
  renderer.setSize( window.innerWidth, window.innerHeight );
  document.body.appendChild(renderer.domElement);

  intermediateRenderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
    format: THREE.RGBAFormat,
    type: THREE.FloatType
  });

  createMaterials();

  const controls = new OrbitControls(camera, renderer.domElement);

  const obj = new OBJLoader().parse(monkeyObjStr);
  const originalMesh = obj.children[0];

  const intermediateMesh = new THREE.Mesh(originalMesh.geometry, new THREE.RawShaderMaterial({
    vertexShader: meshIntermediateVertexShader,
    fragmentShader: meshIntermediateFragmentShader
  }));
  intermediateMesh.rotation.x = -Math.PI / 2.0;
  normalScene.add(intermediateMesh);

  const displayMesh = new THREE.Mesh(originalMesh.geometry, meshDisplayMaterial);
  displayMesh.rotation.x = -Math.PI / 2.0;
  displayScene.add(displayMesh);

  createPlane();

  const animate = function () {
    requestAnimationFrame( animate );
    controls.update();

    renderer.setRenderTarget(intermediateRenderTarget);
    renderer.render(normalScene, camera);


    if (planeLocationOrientationChanged) {
      const pixelData = new Float32Array(4);
      gl.readPixels(mouseX, window.innerHeight-mouseY-1, 1, 1, gl.RGBA, gl.FLOAT, pixelData);
      updateClickPosAndNormal(pixelData);
      setPlaneRotationTranslationMatrix();
      setPlaneScaleMatrix();
      updatePlane();
      planeLocationOrientationChanged = false;
    }
    if (planeScaleChanged) {
      setPlaneScaleMatrix();
      updatePlane();
      planeScaleChanged = false;
    }
    renderer.setRenderTarget(null);
    renderer.render(displayScene, camera);
  };

  setUpGui();
  animate();
}

function createPlane() {
  const planeGeometry = new THREE.PlaneGeometry(1, 1, 1);
  planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
  displayScene.add(planeMesh);
}

function addDecal() {
  const decalGeometry = createDecalGeometry();
  const decalMesh = new THREE.Mesh(decalGeometry, decalMaterial);
  displayScene.add(decalMesh);
}

function createMaterials() {
  // const imgUrl = 'https://upload.wikimedia.org/wikipedia/commons/thumb/7/7a/Red_Arrow_Right.svg/1200px-Red_Arrow_Right.svg.png';
  const imgUrl = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOAAAADgCAMAAAAt85rTAAAAY1BMVEX///8AAACtra3T09PZ2dmkpKT8/PwEBASPj4/d3d3u7u6enp7Jycne3t7V1dX19fVcXFwzMzO4uLjn5+d4eHh+fn6FhYVtbW1JSUkVFRWSkpKLi4s1NTWurq6EhIR3d3dERET2fOTWAAAEJ0lEQVR4nO2dW3LbMAxFST/IKraUNm7aPJqm+19lSefHiSVZA9ADXBhnAQnO3GtS0mjEEBzHcRzHcRzHcRzHcRxHJ4eXLZVVCEl6/AXsIpmfEIJhS/XL8VF69mVsy6hEHjFaaj9D6u8wRxTDX9QMqyFCScmGGaalrAwhIBtmb6kWvKXTIaIY/iULohg+mr9q+031y+XeAoBEN4wYhjVDYkszyv0hNcMM0lLG7zDGd+nZl8FaaUy3FGfHZ7QUZD/8bj5DqmHZY75Jz74McobVEKGk9AxzfJGefRmsDCHwlk5RVhpvqRLst/SJqAezH6Yn+lOMV4AMEz1DEMPAaumr9OzL8JZOZphxMiRzC4bqW1oHtL8f/qBniHFNc2/bMCW6IUxL7/+YzrBMSDbEeIqRuBkiYLylidNSlKcYvN1CPyncPXMMEVpKNoTZDzkZAlx515aS738RDEtJWS3FuD803lLWSoPwFKMmwMsQgTu6IERLQzhQ9WD2w0OkPy99AXgXI9EzLOz0C3IMczVEgNNS4xlGjAxvwbBnGepvKWM/XJLhej0Mw1qO+r+H1fUyTIw/rYR5QwOC8y21IDifofRwTZjLUHq2NswYSo/WiOmWSk/WiskMpQdrxlSG0nO1Y8JQeqyGjLdUeqqWjGYoPVRTxgylZ2rLSEulR2rMeYbSE7XmLEPpgZrz1VB6nvZ8aan0OFdgZzzBo2EyLfippdKzXIed7YrGU0PpSa5EZ1ywN17Rzvgi0x9fxbEr2H26lJGepj2d8Uu17rSf1gTzWX7GBEf8jAl+7ac1wfP8bAn2xh8bjvoZEhzrpyXB/nx9MSXYj8kZEpz0MyI41U8rguPrpx3B6X7aeE9mpp9FcCXN29tq9fCP4Tex/6mCcWLFfH5Bx5vr5LMOQPLbMl7bRvBb8fzUCzLO4gDIL3k/Z7i0fsqTAudl7e7yPxCHk99GxxY3y1ukCw5Bu2AKD9TwcvXTbVch+8XaTww/Uj8h8mP0MyL48fpp2q/0cy09/AJuIT/6/qf/+ozXT+V6hT3VLwL0MzH8IPJLxv2s9/OYH235hNj/GP2MOP20vP/x1hf9DFS/CLC+FLpou58dNTyI+9tjfuTnZ+r9yngbxv6n3q/Mt6GGh5BfoWc939Xux8gvfzzf1Q1j/YwY/eR8dgth/+N8OA3h+przuSaEfpI/uAWR30300+71WWD4gdz/cdYXkH5y/JQLJtYHfPcA+d0909eXvfbXCwLvE9N7hH7y/KQFLmK7n9z8tAt6Py/4KRe0nx/nSB7968uHH7WgCP3k5adcLxzzM7z/HY81y5x+6hZMzPx021VqfnQ/5YKc4y8jxvVZMt5PzmHX6ve/xDuQHSC/xMtPv2DNz+7+xzu2FKCfIRzWw4bGcEDop+M4juM4juM4juM4juOc8B9WvmLR8883OAAAAABJRU5ErkJggg==';

  const arrowTexture = new THREE.TextureLoader().load(imgUrl);
  planeMaterial = new THREE.RawShaderMaterial({
    uniforms: {
      arrowTexture: {value: arrowTexture}
    },
    vertexShader: planeVertexShader,
    fragmentShader: planeFragmentShader,
    transparent: true
  });

  meshDisplayMaterial = new THREE.RawShaderMaterial({
    uniforms: {
      lightDirection: {value: sphericalToCartesianDirection(lightParameters.azimuth, lightParameters.elevation)},
      ambient: {value: lightParameters.ambient}
    },
    vertexShader: meshDisplayVertexShader,
    fragmentShader: meshDisplayFragmentShader
  });

  decalMaterial = new THREE.RawShaderMaterial({
    uniforms: {
      lightDirection: {value: sphericalToCartesianDirection(lightParameters.azimuth, lightParameters.elevation)},
      ambient: {value: lightParameters.ambient},
      normalDepthTexture: {value: intermediateRenderTarget.texture},
      arrowTexture: {value: arrowTexture}
    },
    vertexShader: decalVertexShader,
    fragmentShader: decalFragmentShader,
    depthTest: false,
    depthWrite: false,
    transparent: true
  });
}

function setUpGui() {
  const gui = new dat.GUI({name: 'Decal Parameters'});
  const decalParamFolder = gui.addFolder('Decal Parameters');
  decalParamFolder.add(decalParameters, 'orientation', 0.0, Math.PI * 2.0).name("orientation (W/S)").step(0.01).listen();
  decalParamFolder.add(decalParameters, 'size', 0.5, 2.0).name("size (A/D)").step(0.1).listen().onChange(() => updatePlane());
  decalParamFolder.open();
  const lightParamFolder = gui.addFolder('Light Parameters');
  lightParamFolder.add(lightParameters, 'azimuth', 0.0, Math.PI * 2.0).step(0.01).onChange(() => updateLightDirectionUniforms());
  lightParamFolder.add(lightParameters, 'elevation', -Math.PI/2.0, Math.PI/2.0).step(0.01).onChange(() => updateLightDirectionUniforms());
  lightParamFolder.add(lightParameters, 'ambient', 0.0, 0.5).step(0.01).onChange(() => updateAmbientUniforms());
  lightParamFolder.open();
}

function updateLightDirectionUniforms() {
  const lightDirection = sphericalToCartesianDirection(lightParameters.azimuth, lightParameters.elevation);
  meshDisplayMaterial.uniforms.lightDirection.value.set(lightDirection.x, lightDirection.y, lightDirection.z);
  decalMaterial.uniforms.lightDirection.value.set(lightDirection.x, lightDirection.y, lightDirection.z);
}

function updateAmbientUniforms() {
  meshDisplayMaterial.uniforms.ambient.value = lightParameters.ambient;
  decalMaterial.uniforms.ambient.value = lightParameters.ambient;
  meshDisplayMaterial.needsUpdate = true;
  decalMaterial.needsUpdate = true;
}

function sphericalToCartesianDirection(azimuth, elevation) {
  return new THREE.Vector3 (
    Math.cos(elevation) * Math.cos(azimuth),
    Math.sin(elevation),
    Math.cos(elevation) * Math.sin(azimuth)
  );
}

function createDecalGeometry() {
  const planeGeometry = new THREE.PlaneBufferGeometry(2, 2, 1);
  const spherePositionTypedArray = new Float32Array(6*3);
  const sphereNormalTypedArray = new Float32Array(6*3);
  const uDirectionTypedArray = new Float32Array(6*3);
  for (let vid = 0; vid < 6; vid++) {
    spherePositionTypedArray[vid*3 + 0] = clickPos.x;
    spherePositionTypedArray[vid*3 + 1] = clickPos.y;
    spherePositionTypedArray[vid*3 + 2] = clickPos.z;
    sphereNormalTypedArray[vid*3 + 0] = clickNormal.x;
    sphereNormalTypedArray[vid*3 + 1] = clickNormal.y;
    sphereNormalTypedArray[vid*3 + 2] = clickNormal.z;
    uDirectionTypedArray[vid*3 + 0] = uDirection.x;
    uDirectionTypedArray[vid*3 + 1] = uDirection.y;
    uDirectionTypedArray[vid*3 + 2] = uDirection.z;
  }

  const spherePositionAttribute = new THREE.BufferAttribute(spherePositionTypedArray, 3, false);
  const sphereNormalAttribute = new THREE.BufferAttribute(sphereNormalTypedArray, 3, false);
  const sphereRadiusAttribute = new THREE.BufferAttribute(new Float32Array(6).fill(decalParameters.size * 0.35), 1, false);
  const uDirectionAttribute = new THREE.BufferAttribute(uDirectionTypedArray, 3, false);

  planeGeometry.setAttribute('spherePosition', spherePositionAttribute);
  planeGeometry.setAttribute('sphereNormal', sphereNormalAttribute);
  planeGeometry.setAttribute('sphereRadius', sphereRadiusAttribute);
  planeGeometry.setAttribute('uDirection', uDirectionAttribute);

  return planeGeometry;
}

function getTexCoord() {
  return new THREE.Vector2(mouseX/window.innerWidth, (window.innerHeight-mouseY-1.0)/window.innerHeight);
}

function updateClickPosAndNormal(data) {
  clickNormal = new THREE.Vector3(data[0], data[1], data[2]).normalize();
  clickPos = calculateWorldPositionFromDepth(camera, getTexCoord(), data[3]);
}

function setPlaneRotationTranslationMatrix() {
  const planeInitialNormal = new THREE.Vector3(0, 0, 1);
  const rotationAxis = new THREE.Vector3();
  rotationAxis.crossVectors(planeInitialNormal, clickNormal).normalize();
  const cosAngle = planeInitialNormal.dot(clickNormal);

  planeRotationTranslationMatrix.makeRotationAxis(rotationAxis, Math.acos(cosAngle));
  planeRotationTranslationMatrix.multiply(new THREE.Matrix4().makeRotationZ(decalParameters.orientation));

  const planePosition = clickNormal.clone().multiplyScalar(0.01).add(clickPos);
  planeRotationTranslationMatrix.setPosition(planePosition.x, planePosition.y, planePosition.z);
}

function setPlaneScaleMatrix() {
  planeScaleMatrix.makeScale(decalParameters.size/2.0, decalParameters.size/2.0, decalParameters.size/2.0);
}

function updatePlane() {
  uDirection.set(1.0, 0.0, 0.0, 0.0);
  uDirection.applyMatrix4(planeRotationTranslationMatrix).normalize();
  planeMesh.matrix.copy(planeRotationTranslationMatrix).multiply(planeScaleMatrix);
  planeMesh.matrixAutoUpdate = false;
}

function calculateWorldPositionFromDepth(camera, texCoord, depth) {
    const z = depth * 2.0 - 1.0;
    const position = new THREE.Vector4(texCoord.x * 2.0 - 1.0, texCoord.y * 2.0 - 1.0, z, 1.0);
    position.applyMatrix4(camera.projectionMatrixInverse);
    position.multiplyScalar(1/position.w);
    position.applyMatrix4(camera.matrixWorld);

    return new THREE.Vector3(position.x, position.y, position.z);
}

function onWindowResize() {
  renderer.setSize(window.innerWidth, window.innerHeight);
  intermediateRenderTarget.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
}

window.onload = main;
window.onresize = onWindowResize;

document.addEventListener('mousemove', (event) => {
  mouseX = event.clientX;
  mouseY = event.clientY;
  planeLocationOrientationChanged = true;
});

document.addEventListener('mousedown', (event) => {
  addDecal();
});

document.addEventListener('keydown', (event) => {
  if (event.keyCode === 87) {
    decalParameters.orientation = (decalParameters.orientation + Math.PI/12.0 + Math.PI * 2.0) % (Math.PI * 2.0);
    planeLocationOrientationChanged = true;
  } else if (event.keyCode === 83) {
    decalParameters.orientation = (decalParameters.orientation - Math.PI/12.0 + Math.PI * 2.0) % (Math.PI * 2.0);
    planeLocationOrientationChanged = true;
  } else if (event.keyCode === 65) {
    decalParameters.size = Math.min(decalParameters.size + 0.1, 2.0);
    planeScaleChanged = true;
  } else if (event.keyCode === 68) {
    decalParameters.size = Math.max(decalParameters.size - 0.1, 0.5);
    planeScaleChanged = true;
  }
});

</script>
</body>
</html>
